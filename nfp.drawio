<mxfile host="65bd71144e">
    <diagram id="Odg2zIhy2llCV7wVzy6m" name="Page-1">
        <mxGraphModel dx="2698" dy="1049" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="850" pageHeight="1100" math="1" shadow="0">
            <root>
                <mxCell id="0"/>
                <mxCell id="1" parent="0"/>
                <mxCell id="2" value="Algorithm-5:&lt;br&gt;Decide if two pieces intersects each other" style="rounded=1;whiteSpace=wrap;html=1;align=left;" vertex="1" parent="1">
                    <mxGeometry y="330" width="440" height="40" as="geometry"/>
                </mxCell>
                <mxCell id="3" value="Algorithm-6:&lt;br&gt;Decide if a point is inside a shape" style="rounded=1;whiteSpace=wrap;html=1;align=left;" vertex="1" parent="1">
                    <mxGeometry y="380" width="440" height="30" as="geometry"/>
                </mxCell>
                <mxCell id="4" value="Algorithm-7: &lt;br&gt;Decide if a shape is completely inside another shape" style="rounded=1;whiteSpace=wrap;html=1;align=left;" vertex="1" parent="1">
                    <mxGeometry y="550" width="440" height="40" as="geometry"/>
                </mxCell>
                <mxCell id="5" value="Algorithm-8: &lt;br&gt;Builds a piece containing all the aera at the left of a given piece" style="rounded=1;whiteSpace=wrap;html=1;align=left;" vertex="1" parent="1">
                    <mxGeometry y="620" width="440" height="40" as="geometry"/>
                </mxCell>
                <mxCell id="6" value="Algorithm-9: &lt;br&gt;Computes the horizontal distance from a point to a given segment. Distance is zero if the point is along the segment . Distance is positive if the point is in the right of the segment .Otherwise it is negative." style="rounded=1;whiteSpace=wrap;html=1;align=left;" vertex="1" parent="1">
                    <mxGeometry y="690" width="440" height="68" as="geometry"/>
                </mxCell>
                <mxCell id="7" value="Algorithm-10:&amp;nbsp; &lt;br&gt;Computes the distance that a given piece can be moved to the left without overlapping other pieces and without exceeding the object limits." style="rounded=1;whiteSpace=wrap;html=1;fontStyle=0;align=left;" vertex="1" parent="1">
                    <mxGeometry y="780" width="440" height="60" as="geometry"/>
                </mxCell>
                <mxCell id="8" value="Algorithm-11:&amp;nbsp; &lt;br&gt;Measures the distance in which two segments conincide" style="rounded=1;whiteSpace=wrap;html=1;fontStyle=0;align=left;" vertex="1" parent="1">
                    <mxGeometry y="870" width="440" height="50" as="geometry"/>
                </mxCell>
                <mxCell id="9" value="&lt;h1&gt;5 Algorithm for geometric computation&lt;/h1&gt;&lt;p&gt;The algorithm presented in this section are the building blocks for implementing the &lt;b&gt;&lt;u&gt;placement heuristics&lt;/u&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;These algorithms are suited for dealing with convex and nonconvex shapes(even though our tested instances have only convex pieces).&lt;/p&gt;&lt;p&gt;Each piece is represented by its vertices coordinates ordered counterclockwise.&lt;/p&gt;&lt;p&gt;Algorithms are mainly devoted to&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;i&gt;&lt;u&gt;1. the task of detecting overlapping.(Algorithms 5,6,7)&lt;/u&gt;&lt;/i&gt;&lt;/p&gt;&lt;p&gt;&lt;i&gt;&lt;u&gt;2. to compute the distance that one piece can slide without crossing to another(Algorithms 9,10)&lt;/u&gt;&lt;/i&gt;&lt;/p&gt;&lt;p&gt;&lt;i&gt;&lt;u&gt;3. to compute adjacency(Algorithm 11)&lt;/u&gt;&lt;/i&gt;&lt;/p&gt;&lt;p&gt;Most of the algorithms are based on basic geometrical concepts, but particular cases and exceptions deserve special care.&lt;/p&gt;&lt;p&gt;The easiest-to-solve cases should be reviewed first in order to avoid unnecessary computations.&lt;/p&gt;&lt;p&gt;For example, when checking whether&amp;nbsp; a point is inside a shape, a quickcomputation to determine is the point is above(or below) the top or (the bottom) of the piece will discard many cases.&amp;nbsp;&lt;/p&gt;&lt;p&gt;Trivial cases like this one are a frequent scenario when applying the placement heuristics with our set of instancs.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;" style="text;html=1;strokeColor=none;fillColor=none;spacing=5;spacingTop=-20;whiteSpace=wrap;overflow=hidden;rounded=0;" vertex="1" parent="1">
                    <mxGeometry x="450" y="305" width="440" height="490" as="geometry"/>
                </mxCell>
                <mxCell id="12" style="edgeStyle=none;html=1;exitX=0;exitY=0.25;exitDx=0;exitDy=0;entryX=0.5;entryY=1;entryDx=0;entryDy=0;fillColor=#e51400;strokeColor=#B20000;strokeWidth=5;" edge="1" parent="1" source="10" target="2">
                    <mxGeometry relative="1" as="geometry"/>
                </mxCell>
                <mxCell id="10" value="&lt;h1&gt;&lt;font color=&quot;#f29107&quot;&gt;Two considerations to take into account are:&lt;/font&gt;&lt;/h1&gt;&lt;p&gt;&lt;u&gt;&lt;font color=&quot;#f29107&quot;&gt;1. Our function that reviews if two segments have an intersection returens &lt;/font&gt;&lt;font color=&quot;#ff3333&quot;&gt;false&lt;/font&gt;&lt;font color=&quot;#f29107&quot;&gt; if they belong to the same line, even if one segment touch the other by one of their ends or if they overlap. In other words, &lt;/font&gt;&lt;font color=&quot;#f22b07&quot;&gt;our definition of intersection of segments refers to segments that crosses but are not coincident.&lt;/font&gt;&lt;font color=&quot;#f29107&quot;&gt; Note that this definition implies that reviewing for intersection of two segments that are exactly the same, the function will return false.(TEST)&lt;/font&gt;&lt;/u&gt;&lt;/p&gt;&lt;p&gt;&lt;u&gt;&lt;font color=&quot;#f29107&quot;&gt;2. Our function that reviews if a point is inside a segment return true if the point is one of the ends of the segment. When the sum of the distances from the point to the two ends of the segment is equal to the segment length, then we consider that the point belongs to the segment.&lt;/font&gt;&lt;/u&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;" style="text;html=1;strokeColor=none;fillColor=none;spacing=5;spacingTop=-20;whiteSpace=wrap;overflow=hidden;rounded=0;" vertex="1" parent="1">
                    <mxGeometry x="450" y="815" width="440" height="240" as="geometry"/>
                </mxCell>
                <mxCell id="13" value="&lt;h1&gt;Algorithm-5&lt;/h1&gt;&lt;p&gt;To konw whether two pieces intersects each other,a routine that checks intersection for each pair of sides from both pieces was implemented.&lt;/p&gt;&lt;p&gt;Initially, a revision is done to confirm that the &lt;u&gt;orthogonal rectangles&lt;/u&gt; that circumscribe both pieces intersect.&lt;/p&gt;&lt;p&gt;This is used to discard the easiest non-intersection cases.&lt;/p&gt;&lt;p&gt;This test does not work if one piece is completely inside the other, in which case no edges intersect but the pieces do intersect.&lt;/p&gt;&lt;p&gt;In consequence, this algorithm is always followed by Algorithm 7 that reviews if one piece is complete inside another&lt;/p&gt;" style="text;html=1;strokeColor=none;fillColor=none;spacing=5;spacingTop=-20;whiteSpace=wrap;overflow=hidden;rounded=0;fontColor=#FFFFFF;" vertex="1" parent="1">
                    <mxGeometry y="40" width="440" height="232" as="geometry"/>
                </mxCell>
                <mxCell id="14" value="&lt;h1&gt;Algorithm-6&lt;/h1&gt;&lt;p&gt;Algorithm6 determines whether a point is inside a shape.&lt;/p&gt;&lt;p&gt;If the point is along an edge of the piece or one of its vertices, them the algorithm will return false.&lt;/p&gt;&lt;p&gt;The basic idea is to trace a ray from the point to any fixed direction.&lt;/p&gt;&lt;p&gt;If the ray cuts the shape an odd number of times, then the point is inside the shape; otherwise it is outside.&lt;/p&gt;&lt;p&gt;If the ray touches or if it actually crosses the shape.&lt;/p&gt;&lt;p&gt;This is done employging the D-function.&lt;/p&gt;&lt;p&gt;For line intersection, the D-function gives the relative position of a point P with respect to an oriented edge AB. The D-function is defined as flowws:&lt;/p&gt;&lt;p&gt;$$D_{ABP} = (X_A - X_B)(Y_A - Y_P) - (Y_A-Y_B)(X_A-X_P)$$&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;Depending if $$D_{ABP}$$ is negative or positive, the point P is on the left or the right side of the edge AB.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;The definition of left and right is as follows: if an observer would stand at point A looking in the direction of B, point P would be at the observer's left or right.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;If $$D_{ABP} = 0$$, the point P is on the supporting line of edge AB&lt;br&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;" style="text;html=1;strokeColor=none;fillColor=none;spacing=5;spacingTop=-20;whiteSpace=wrap;overflow=hidden;rounded=0;fontColor=#FFFFFF;" vertex="1" parent="1">
                    <mxGeometry x="-450" y="40" width="440" height="502" as="geometry"/>
                </mxCell>
                <mxCell id="17" value="&lt;h1&gt;Algorithm-7&lt;/h1&gt;&lt;p&gt;Algorithm 7 is used to determine if a piece is completely inside another piece.&lt;/p&gt;&lt;p&gt;Initially, a revision is done to confirm that the orthogonal rectangles that circumscribe both pieces intersect and that the actual pieces do not intersect(part 1)&lt;/p&gt;&lt;p&gt;If both pieces do not intersect, we find the orthogonal rectangle that circumscribe both pieces at the same time.&lt;/p&gt;&lt;p&gt;If the area of this rectangle is less than the sum of areas of both pieces, it means unequivocally that one piece is inside the another(part 2).&lt;/p&gt;&lt;p&gt;If the point in the middle of piece 1 is inside piece 1, then we check if this point is inside piece 2.&lt;/p&gt;&lt;p&gt;The same is checked for the middle point of p[iece 2(part 3)&lt;/p&gt;&lt;p&gt;If this is not hte case, then all vertices and edge midpoints from both pieces are checked to know if they are inside the other piece.&amp;nbsp;&lt;/p&gt;&lt;p&gt;Checking vertices and edges midpoints is not an infalli ble test with non-conves shapes.&lt;/p&gt;&lt;p&gt;It is possible to find a case where all vertices edges midpoints of the inside shape are all along the contour of the larger piece.&lt;/p&gt;&lt;p&gt;See for example Fig.3&amp;nbsp;&lt;/p&gt;&lt;p&gt;Therefore, two points close to each vertex(one for each of the edges) are also tested(part 4)&lt;/p&gt;&lt;p&gt;Finally, it is convenient to check whether the two pieces are not equal and in the same position(part 5)&lt;/p&gt;" style="text;html=1;strokeColor=none;fillColor=none;spacing=5;spacingTop=-20;whiteSpace=wrap;overflow=hidden;rounded=0;fontColor=#FFFFFF;" vertex="1" parent="1">
                    <mxGeometry x="-440" y="550" width="440" height="500" as="geometry"/>
                </mxCell>
                <mxCell id="18" value="&lt;h1&gt;Algorithm 8&lt;/h1&gt;&lt;div&gt;Algorithm 8 builds a piece that holds all the area in the object that is left of a given piece.&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;A similar procedure is done to build a piece containing all the area below a given piece&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;" style="text;html=1;strokeColor=none;fillColor=none;spacing=5;spacingTop=-20;whiteSpace=wrap;overflow=hidden;rounded=0;fontColor=#FFFFFF;verticalAlign=top;" vertex="1" parent="1">
                    <mxGeometry x="-440" y="1055" width="440" height="130" as="geometry"/>
                </mxCell>
                <mxCell id="19" value="&lt;h1&gt;Algorithm 9&lt;/h1&gt;&lt;div&gt;Algorithm 9 computes the distance by which a point can reach horizontally a segment.&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;An analogous procedure finds a vertical distance from a point to a given segment.&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;" style="text;html=1;strokeColor=none;fillColor=none;spacing=5;spacingTop=-20;whiteSpace=wrap;overflow=hidden;rounded=0;fontColor=#FFFFFF;verticalAlign=top;" vertex="1" parent="1">
                    <mxGeometry x="-440" y="1190" width="440" height="130" as="geometry"/>
                </mxCell>
                <mxCell id="20" value="&lt;h1&gt;Algorithm 10&lt;/h1&gt;&lt;div&gt;Algorithms 8 and 9 are needed when executing Algorithm 10 which computes the distance that a given piece can be moved to the left avoiding collision against other pieces in the object and without exceeding the object limits.&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;A similar procedure was implemented in this investigation to find how much a given piece can be moved down.&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;The implementation of this algorithm is basic for bottom-left moves that take place in all placement heuristics&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;" style="text;html=1;strokeColor=none;fillColor=none;spacing=5;spacingTop=-20;whiteSpace=wrap;overflow=hidden;rounded=0;fontColor=#FFFFFF;verticalAlign=top;" vertex="1" parent="1">
                    <mxGeometry y="930" width="440" height="190" as="geometry"/>
                </mxCell>
                <mxCell id="21" value="&lt;h1&gt;Algorithm-11&lt;/h1&gt;&lt;div&gt;Algorithm 11 returns the distance in which two segments coincide.&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;This algorithm constitutes the basis for implementing the heuristic called Consturctive Approach with Maximum Adjacency.&lt;/div&gt;" style="text;html=1;strokeColor=none;fillColor=none;spacing=5;spacingTop=-20;whiteSpace=wrap;overflow=hidden;rounded=0;fontColor=#FFFFFF;" vertex="1" parent="1">
                    <mxGeometry y="1120" width="440" height="120" as="geometry"/>
                </mxCell>
            </root>
        </mxGraphModel>
    </diagram>
</mxfile>